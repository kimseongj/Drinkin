#  Drinkin
<img src="https://github.com/kimseongj/Drinkin/assets/88870642/9824b4ad-dca2-473e-bf3a-dfc2ffe7b76b" width=200>

<br/>
<br/>

>홈텐딩 도우미 🥃🍹 *Drinkin*
>
>개발기간: 2023.07.01~2023.12.21

<br/>
>Drinkin은 맛있는 칵테일을 집에서 직접 즐길 수 있도록 도와주는 홈텐딩 도우미 앱입니다. 개인이 가지고 있는 재료와 마셔봤던 칵테일을 기준으로 칵테일을 추천을 해주고, 추천 받은 칵테일들에 대한 상세 설명 및 제조법을 알려드립니다. 



## ⚒️ 기능 소개
홈텐딩 도우미가 되겠습니다!

사용자에게 맞는 칵테일을 추천해드려요!

칵테일 제조법뿐만 아니라 기법, 도구 등 상세하게 설명해드릴게요!

만들어보고 싶은 칵테일, 만들어본 칵테일을 저장할 수 있답니다!

### 메인 

|로그인|마셔봤던 칵테일 선택|칵테일 추천|
|:----:|:----:|:----:|
|<img src="https://github.com/kimseongj/Drinkin/assets/88870642/c2b656e1-4c95-4feb-90f6-d53a4117dc32" width=200>|<img src="https://github.com/kimseongj/Drinkin/assets/88870642/7c118e6d-0136-4bc2-a163-cf132e720be7" width=200>|<img src="https://github.com/kimseongj/Drinkin/assets/88870642/dcc8ab2e-0add-40fe-9967-7aeba238b57c" width=200>|
|소셜로그인인 카카오 로그인, 애플 로그인으로 로그인을 구현하였습니다.|이용자 맞춤 칵테일 추천을 위해 이용자가 마셔봤던 칵테일을 선택합니다.|이용자에게 맞춤 칵테일을 추천해주고 클릭시 상세정보를 확인할 수 있습니다.|

### 칵테일

|칵테일 검색|칵테일 상세정보1|칵테일 상세정보2|
|:----:|:----:|:----:|
|<img src="https://github.com/kimseongj/Drinkin/assets/88870642/71cb331b-6a83-4527-830d-61204419b06d" width=200>|<img src="https://github.com/kimseongj/Drinkin/assets/88870642/1c032c5e-a3ed-474f-ab29-b0f37917575b" width=200>|<img src="https://github.com/kimseongj/Drinkin/assets/88870642/401d6c73-c54c-4dc5-a16b-12d9d04fd1b7" width=200>|
|칵테일 특징을 단계별로 표현하여 이용자가 칵테일을 필터링하고 검색할 수 있습니다. |칵테일에 필요한 재료에 대한 설명과 클릭시 재료의 상세정보를 볼 수 있습니다.|칵테일을 제조 시 필요한 도구에 대해 확인할 수 있고, 북마크할 수 있습니다.|
|**베이스 종류정보**|**재료로 만들 수 있는 칵테일**|**재료 상세정보**|
|<img src="https://github.com/kimseongj/Drinkin/assets/88870642/32eb06cd-1b97-4c96-b361-447d4b485519" width=200>|<img src="https://github.com/kimseongj/Drinkin/assets/88870642/dfc8ac9f-1990-4bb6-9729-3502ab97ce19" width=200>|<img src="https://github.com/kimseongj/Drinkin/assets/88870642/8a813c19-d17d-4978-909b-7246c83e3d83" width=200>|
|칵테일 베이스에 대한 브랜드들을 나열하고 클릭시 상세정보를 확인할 수 있습니다.|클릭한 재료로 만들 수 있는 칵테일을 리스트화해서 보여줍니다.|상세페이지에서 도구를 클릭했을 때 볼 수 있는 도구 상세정보입니다.|

### 나의 홈바

|나의 홈바|재료 추가|칵테일 북마크된 리스트|
|:----:|:----:|:----:|
|<img src="https://github.com/kimseongj/Drinkin/assets/88870642/18d4699e-f5f9-4aac-98a5-40707fc665a4" width=200>|<img src="https://github.com/kimseongj/Drinkin/assets/88870642/cc9aa2e2-6f47-48de-85b8-1201914b70bc" width=200>|<img src="https://github.com/kimseongj/Drinkin/assets/88870642/b04f1bdc-4932-4291-b2f9-3a30296f1560" width=200>|
|이용자가 보유한 재료를 확인하고 북마크한 칵테일, 로그인, 회원탈퇴를 관리합니다.|이용자가 보유한 재료를 필터링, 검색 기능을 통해 선택하거나 제거할 수 있습니다.|북마크된 칵테일을 리스트화해서 확인하고, 클릭시 칵테일 상세정보가 나옵니다.|

### 주요기능 실행 
|칵테일 검색|재료 추가|마셔봤던 칵테일 선택|
|:----:|:----:|:----:|
|<img src="https://github.com/kimseongj/Drinkin/assets/88870642/d9a552bf-00b6-49da-963a-78c51ab02c2f" width=200>|<img src="https://github.com/kimseongj/Drinkin/assets/88870642/faeca8ce-5eba-48d6-afe1-b9f5963aafce" width=200>|<img src="https://github.com/kimseongj/Drinkin/assets/88870642/86d0a30b-c1a8-432d-85ea-a41d17eac4da" width=200>|




## ⚙️ 기술 스택
<img src="https://img.shields.io/badge/CleanArchitecture-0080FF?style=flat-square"/> <img src="https://img.shields.io/badge/MVVM-100AF?style=flat-square"/> <img src="https://img.shields.io/badge/Coordinator-019999?style=flat-square"/> <img src="https://img.shields.io/badge/Combine-AAA1AF?style=flat-square"/> <img src="https://img.shields.io/badge/Network-100000?style=flat-square"/> <img src="https://img.shields.io/badge/ModernCollectionView-FF0000?style=flat-square"/> <img src="https://img.shields.io/badge/KeyChain-EEE6C4?style=flat-square"/> <img src="https://img.shields.io/badge/SPM-DDA2FF?style=flat-square"/>

## 📝 아키텍쳐
### CleanArchitecture + MVVM-C
<img src="https://github.com/kimseongj/Drinkin/assets/88870642/de3eee86-f816-4040-aa51-103bac8535f7"/>


## 🏃기술적 도전
<details>
    <summary><big>Clean Architecture</big></summary> 
    
### Clean Architecture

>   Clean Architecture를 저만의 해석을 바탕으로 이해하려고 노력했습니다.
> 일단, Clean Architeture를 사용하면서 느낀 것은 객체의 모듈화가 정말 잘되어있는 아키텍쳐 디자인이라고 생각됩니다. MVVM의 경우 ViewModel에서 비즈니스 로직을 담당하고,  Model과 상호작용하여 데이터를 주고 받습니다. 그렇다면 여러 비즈니스 로직이 하나의 ViewModel에서 구현되어 ViewModel의 부피가 커지게 되며, 복잡성이 생길 수 있습니다. Clean Architecture는 ViewModel의 비즈니스 로직을 Usecase라는 객체를 생성하여 하나씩 분리합니다. 즉, 모듈성이 극대화된다고 생각합니다. 모듈성이 강해지면, unit test와 refactoring 시 유리할 것 같습니다. 또한, 기능에 따라 객체를 분리함으로써 유지보수성, 확장성, 테스트 용이성을 보장해줍니다. 

**현재 프로젝트에서 사용**
- Repository를 Entity별로 구현하고, 해당 Repository에 대한 Interface를 Domain에 구현하여 의존성 역전을 시킨 형태입니다. Repository를 통해 외부 데이터의 api를 호출하는 기능을 수행합니다.
- Usecase의 경우 사용자와 상호작용하는 로직만을 비즈니스 로직으로 취급하여 구현하였습니다. 예를 들어, 로그인, 로그아웃, 칵테일 필터링, 칵테일 선택 등이 있습니다. Domain의 Repository Intreface에 의존하는 형태를 띄고 있습니다.
- Presentation Layer에 속한 ViewController, ViewModel은 MVVM의 ViewModel, View를 합친 형태로 UI에 대한 업데이트, 사용자와 상호작용을 책임집니다. ViewModel은 Repository(Interface), Usecase에 의존하여 UI와 상호작용합니다.

 </details>

    
<details>
    <summary><big>Coordinator 패턴의 적용</big></summary>
    
### Coordinator 패턴의 적용

> Coordinator 패턴은 ViewController 간의 흐름을 관리하는 디자인 패턴으로 사용됩니다. 하나의 ViewController의 화면 전환 및 인스턴스를 관리하는 역할을 할 수 있습니다.

:fire: **Coordinator 패턴을 적용했을 때 느낀점**

1. 한개의 `ViewController`가 앱 흐름에 따라 여러 곳에서 호출될 때, `Coordinator`를 구현하면,  `Coordinator`를 재사용하여 쉽게 앱의 흐름을 구현할 수 있습니다.
2. `ViewController` 내부에 다음 UI에 대한 `ViewController`를 인스턴스로 만들어서 화면 전환을 하면 제 3자의 입장에서 코드를 확인했을 때, 보다 쉽게 흐름을 파악할 수 있을 것 같습니다.
3. 테스트를 실제 진행하지 않았지만, `Coordinator `패턴을 사용할 경우 테스트할 때 전체 앱을 탐색할 필요 없이 모의 `Coordinator`를 만들어 독립 테스트가 가능할 것 같습니다.
4. 하지만 결국 `ViewController`마다 `Coordinator`를 만들기 때문에 화면 수가 적은 앱에서는 필요 이상의 코드들이 생성될 수 있습니다.

:fire:**결론** : 결론적으로 코디네이터 패턴은 복잡한 탐색과 앱 흐름이 있는 앱의 경우 iOS 앱 아키텍처에 효율적인 디자인 패턴이 될 것입니다. 그러나 모든 앱에 필요하거나 소규모 앱에는 적합하지 않을 수 있고, 요구 사항과 복잡성에 따라 채택을 고려해야 할 것 같습니다.

</details>
 
<details>
    <summary><big>Dependency Injection</big></summary> 
    
### Dependency Injection
> 의존성 주입은 클래스 간 결합을 줄이기 위해 외부에서 개체를 생성하여 해당 개체를 필요로 하는 다른 개체에 주입해주는 것입니다. 코드의 분리성, 독립 테스트 용이성 등을 향상시킬 수 있는 좋은 방법입니다. 제 프로젝트에서는 `init()`을 통해 의존성을 주입하는 방법을 선택했습니다. 

:fire: **Dependency Injection을 적용했을 때 느낀 점**

1. DI를 적용하면 코드에 대한 리팩토링을 할 때, 여러 객체들을 찾아가서 의존성을 가지는 인스턴스들을 수정할 필요가 없습니다. 이는 코드 분리성에 있어 이점을 가져갑니다.
2. 독립적인 Test가 가능합니다.
3. 코드의 양이 많아지긴 하지만 협력하는 과정에서 코드를 한층 더 쉽게 이해할 수 있고, UnitTest 시 Mock을 생성해서 주입하는 것이 가능해집니다.

:fire: **결론** : DI는 코드의 양이 늘어날 뿐 그 이상의 단점이 없고, 느슨할 결합을 이뤄낼 수 있게 해주며, 유지보수 Unit 테스트 시에도 편리할 것 같습니다.

</details>

<details>
    <summary><big>MVVM 패턴을 적용하면서 Binding에 대한 고민</big></summary> 
    
### MVVM 패턴을 적용하면서 Binding에 대한 고민

> MVVM 패턴의 경우 `ViewModel`과 `View`를 분리하여 비즈니스로직과 UI로직을 분리해놓습니다. 이 때, `View`에서 사용자와 상호작용을 통해 UI가 변하거나, 시간에 따라 서버에서 새로운 데이터를 보내지 않는 상황에서도 `Binding`을 쓰는게 의미가 있을까 라는 고민이 생겼습니다.

:fire:**결론**: 구현하는 `View`가 단순 데이터를 받아와서 UI를 그리고 `ViewModel`과 양방향 통신을 하지 않는다면 Binding의 의미가 없어진다고 생각이 듭니다. Binding의 목적은 `ViewModel`의 값과 `View`의 속성을 연결하여 데이터 변경에 자동으로 업데이트되도록 하는 것이기 때문입니다. 유연성 있는 코드를 작성하기 위해서 Binding이 필요없는 UI의 경우 Binding을 하지 않는 방향성을 고려해볼 필요가 있다고 생각합니다.
</details>

<details>
    <summary><big>Combine</big></summary> 

### Combine 활용
> Combine은 비동기로 처리되는 예를 들어 값이 변경되거나, 이벤트가 실행되었을 때를 포착해서 원하는 액션을 취할 수 있게 해줍니다. 즉, 옵저버 패턴과 동일한 역할을 한다고 생각합니다. 이러한 Combine을 활용하여 Data Fetch, Binding을 구현했습니다.

- Data Fetch의 경우 `URLSession`의 `dataTaskPublisher`메서드를 통해 API호출을 구현했습니다. 
- Combine을 통해 앱의 상태(로그인 유무), 이용자의 데이터 변화를 Binding을 통해 확인하고, 그에 맞게 UI를 보여줍니다.

</details>
    
<details>
    <summary><big>Diffable Data Source 적용</big></summary> 
    
### Diffable Data Source 적용

> Diffable DataSource는 CollectionView, TableView의 Cell들이 데이터의 변화에 따라 cell들을 재구성하는 역할을 합니다. 이는 물론 DataSource에 존재하는 기능입니다. 하지만 DataSource를 사용할 경우 애니메이션 효과 부분에서 사용자의 UX를 저하시킬 수 있습니다. 이런 부분을 해결하기 위해 DiffableDataSource는 데이터의 달라진 부분을 추적하고 자연스러운 애니메이션을 통해 UI를 업데이트 합니다.



:fire: **주의 사항**
- IndexPath를 사용하지 않고, Hashable을 기반으로 동작합니다.
- UIState의 Truth이며 IndexPath 대신 Section과 Item의 Unique Identifier를 사용합니다. `DiffableDataSource`은 제네릭 타입으로 `Section`과 `item`타입을 받습니다. 이 때 제네릭 타입들은 `Hashable`을 준수해야 합니다. 

:fire: **사용원리**

1. **Connect a diffable data source to your collection view**
   - `DiffableDataSource`를 `CollectionView`가 있는 `ViewController`에 만들어줍니다.

2. **Implement a cell provider to configure your collection view's cells**
   - `CellProvider`를 구현하여, `cell`을 만드는 방식을 구현합니다.

3. **Generate the current state of the data**
   - 데이터에 대한 `snapshot`을 찍어 `DiffableDataSource`에 적용하고 상태를 변화시킵니다.

4. **Display the data in the UI**
   - `UI`에 변화된 상태의 `CollectionView`를 보여줍니다.

(Apple 공식문서 인용)
</details>
        
<details>
    <summary><big>Extension, Enum 활용</big></summary> 
    
### Extension, Enum 활용
:fire: **Extension**
> Extension을 활용하여 UIImageView, UIViewController을 사용할 때 필요한 메서드를 구현하였고, 이를 바탕으로 UIImageView, UIViewController가 사용되는 어느 곳에서든 구현된 메서드를 사용할 수 있게 했습니다.

- UIIMageView
```swift
extension UIImageView {
    func load(url: URL) {
        DispatchQueue.global().async { [weak self] in
            if let data = try? Data(contentsOf: url) {
                if let image = UIImage(data: data) {
                    DispatchQueue.main.async {
                        self?.image = image
                    }
                }
            }
        }
    }
}
```

- UIViewController
```swift
extension UIViewController {
    func makeBlackBackBarButton() {
        let backBarButtonItem = UIBarButtonItem(title: "", style: .plain, target: self, action: nil)
        backBarButtonItem.tintColor = .black
        self.navigationItem.backBarButtonItem = backBarButtonItem
    }
}
```

:fire: **Enum**
> Enum을 활용하여 공통으로 사용하거나 케이스 분리가 필요한 인스턴스와 케이스를 보관하고, static let과 같은 type property를 만들어서 NameSpace, Color, Image등을 관리할 수 있는 enum을 구현했습니다.

- HTTPMethod
```swift
enum HTTPMethod: String {
    case get = "GET"
    case post = "POST"
    case put = "PUT"
    case delete = "DELETE"
}
```

- CategoryListStrings
```swift
enum CategoryListStrings {
    static let whole: String = "전체"
    static let whiskey: String = "위스키 베이스"
    static let liqueur: String = "리큐르 베이스"
    static let vodka: String = "보드카 베이스"
    static let gin: String = "진 베이스"
    static let rum: String = "럼 베이스"
    static let tequila: String = "데킬라 베이스"
    static let nonAlcoholic: String = "논알콜"
    static let mixing: String = "혼합"
}
```
</details>

<details>
    <summary><big>CollectionView LeftAlignmentLayout 구현</big></summary> 
    
### CollectionView LeftAlignmentLayout 구현

> 디자인에 따라 구현함에 있어 CollectionViewCell들이 왼쪽 정렬이 되도록 구현해야 하는 과정이 있었습니다. 왼쪽 정렬을 구현하려면 flowLayout을 커스텀 제작이 필요했습니다. 따라서 아래와 같이 구현했습니다.

:fire: **코드 & 설명**

```swift
class CollectionViewLeftAlignFlowLayout: UICollectionViewFlowLayout {
    let cellSpacing: CGFloat = 8
    
    override func layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]? {
        self.sectionInset = UIEdgeInsets(top: 0, left: 0, bottom: 0, right: 0)
        let attributes = super.layoutAttributesForElements(in: rect)
        
        var leftMargin = sectionInset.left
        var maxY: CGFloat = -1.0
        
        attributes?.forEach { layoutAttribute in
            if layoutAttribute.frame.origin.y >= maxY {
                leftMargin = sectionInset.left
            }
            layoutAttribute.frame.origin.x = leftMargin
            leftMargin += layoutAttribute.frame.width + cellSpacing
            maxY = max(layoutAttribute.frame.maxY, maxY)
        }
        
        return attributes
    }
}
```

- `minimumLineSpacing`을 통해 cell간 최소간격을 표현합니다.
- `sectionInset`으로 Section간 여백을 0으로 설정합니다.
- `super.layoutAttributesForElements(in: rect)`을 사용하여 현재 영역에 있는 `attributes`(각 셀의 크기와 위치 정보)를 가져옵니다.
- `attributes?.forEach`를 통해 각 `cell`의 특성에 접근합니다.
- `maxY`를 -1로 하여 cell의 첫 행일 때, `maxY`보다 값이 크면 `leftMargin`을 `sectionInset.left `(x == 0)인 부분으로 바꿔줍니다.
- 그 이후에 `leftMargin`을 `layoutAttribute.frame.origin.x`에 넣어줌으로써 `cell`의 x위치를 `leftMargin`으로 바꿔줍니다.
- `leftMargin`에 현재 `cell`의 크기 더하기 `leftMargin`을 해서 다시 `leftMargin`에 넣어줍니다.
- `maxY`를 현재 `cell`의 y좌표값과 비교하여 더 큰값을 다시 `maxY`에 넣어줍니다.
</details>



<details>
    <summary><big>KeyChain을 활용한 access/refresh Token 보관</big></summary> 
    
### KeyChain을 활용한 access/refresh Token 보관
>로그인 관리를 위해 AccessToken과 RefreshToken을 보관할 필요가 있었고, KeyChain이 제일 적합하다고 판단하였습니다. KeyChain의 경우 디바이스 내부에 데이터를 복호화하여 저장합니다. 또한 디바이스가 잠금되었을 때 접근이 불가능하며 해당 앱에서만 접근이 가능합니다. 이에 AccessToken, RefreshToken은 민감한 정보라고 판단하였고 KeyChain에 저장하는 방식은 선택했습니다. 
</details>
